{"java":"/*\r\n * @lc app=leetcode id=53 lang=java\r\n *\r\n * [53] Maximum Subarray\r\n *\r\n * https://leetcode.com/problems/maximum-subarray/description/\r\n *\r\n * algorithms\r\n * Easy (42.66%)\r\n * Total Accepted:    458.6K\r\n * Total Submissions: 1.1M\r\n * Testcase Example:  '[-2,1,-3,4,-1,2,1,-5,4]'\r\n *\r\n * Given an integer array nums, find the contiguous subarray (containing at\r\n * least one number) which has the largest sum and return its sum.\r\n * \r\n * Example:\r\n * \r\n * \r\n * Input: [-2,1,-3,4,-1,2,1,-5,4],\r\n * Output: 6\r\n * Explanation: [4,-1,2,1] has the largest sum = 6.\r\n * \r\n * \r\n * Follow up:\r\n * \r\n * If you have figured out the O(n) solution, try coding another solution using\r\n * the divide and conquer approach, which is more subtle.\r\n * \r\n */\r\nclass Solution {\r\n    public int maxSubArray(int[] nums) {\r\n        // https://leetcode.com/problems/maximum-subarray/discuss/20193/DP-solution-and-some-thoughts\r\n        int n = nums.length;\r\n        int[] dp = new int[n];// dp[i] means the maximum subarray ending with nums[i];\r\n        dp[0] = nums[0];\r\n        int max = dp[0];\r\n        for (int i = 1; i < n; i++) {\r\n            dp[i] = nums[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);\r\n            max = Math.max(max, dp[i]);\r\n        }\r\n        return max;\r\n    }\r\n}\r\n"}